I will build the **ACP Python SDK** to serve as the control-plane instrumentation layer. This SDK will deterministically record agent execution into the strict `run_<id>` artifact format required by the VS Code extension.

&#x20;

***

## 1. Project Structure Setup

* Create `ACP-sdk/` directory.
* Initialize a Python project with `pyproject.toml` (modern packaging).
* Structure:
  * `src/acp/` (Main package, public API surface)
  * `src/acp/core/` (Execution recording primitives)
    * Recorder lifecycle management
    * Step boundary definitions
    * Redaction and safety enforcement
  * `src/acp/runtime/` (Execution-boundary hooks)
    * Execution context tracking
    * Step ordering and monotonicity
    * Deterministic replay guarantees
  * `src/acp/integrations/` (Wrappers for LLMs, tools, frameworks)
    * LLM interceptors
    * Tool interceptors
    * Optional framework adapters (LangChain, AutoGen later)
  * `src/acp/config/` (Configuration and limits)
    * Trace limits
    * Redaction rules
    * Feature flags

***

## 2. Core Components Implementation

### **`TraceRecorder`**

The **central authority** for all recorded execution data.

Responsibilities:

* Owns the lifecycle of a single run (`run_id`)
* Writes:
  * `meta.json`
  * `steps.jsonl`
  * snapshot artifacts
* Guarantees:
  * append-only writes
  * monotonic step IDs
  * strict step ordering
  * crash-safe persistence
* Flushes data after every step to avoid data loss

Additional responsibilities to add:

* Enforces **trace growth limits**
  * maximum steps
  * maximum snapshot size
  * records truncation events
* Captures **run-level metadata**
  * agent version
  * LLM identity and parameters
  * enabled tools
  * random seed
  * start/end timestamps
* Exposes a **read-only run context** to other SDK components

***

### **Execution Boundary Model (Missing but Mandatory)**

The SDK must formalize execution into **explicit boundaries**.

Supported phases must include:

* `observe`
* `reason`
* `act`
* `tool`
* `memory`
* `retry`
* `terminate`

Each boundary produces **exactly one or more ordered steps**.

This ensures consistency across frameworks and prevents ambiguous traces.

***

### **`Observation`** **(Decorators / Context Managers)**

Used to instrument execution **without modifying agent logic**.

Responsibilities:

* Wrap user code at execution boundaries
* Notify `TraceRecorder` when:
  * a boundary starts
  * a boundary ends
  * an error occurs
* Capture:
  * inputs entering the boundary
  * outputs leaving the boundary
  * exceptions and retries

Important additions:

* Must support **nested boundaries**
* Must preserve original exceptions (no swallowing)
* Must not change execution timing beyond minimal overhead

***

### **`StateMonitor`**

Responsible for observing **agent state evolution over time**.

Captures:

* memory contents (or references)
* context window size
* internal state variables (when accessible)

Additional required behavior:

* Detects state changes between steps
* Supports:
  * full snapshot capture
  * diff-based snapshot capture (future optimization)
* Provides state hashes for:
  * comparison
  * replay verification

The SDK must treat state capture as **best-effort but deterministic**.

***

## 3. Integration Layer

### **LLM Interceptor**

Wraps LLM calls at runtime.

Responsibilities:

* Capture:
  * fully resolved prompt (after templating)
  * system/user separation if available
  * model name
  * parameters (temperature, top\_p, etc.)
  * raw output
  * errors and retries
* Ensure:
  * no prompt mutation
  * no output post-processing
* Record LLM calls as **reasoning-phase steps**

Additional required behavior:

* Retry detection and grouping
* Explicit marking of failed LLM calls
* Capture latency metrics (optional but recommended)

***

### **Tool Interceptor**

Wraps all callable tools used by the agent.

Responsibilities:

* Capture:
  * tool identity
  * input arguments
  * stdout
  * stderr
  * return value
  * raised exceptions
* Track:
  * retry counts
  * execution duration
* Persist tool outputs **outside** `steps.jsonl` to prevent bloat

Additional required behavior:

* Works for:
  * sync tools
  * async tools
* Guarantees that tool interception does not alter behavior

***

## 4. Execution Logic Coupling (Critical Addition)

The SDK must provide a **single sanctioned entry point** to run agents under control-plane observation.

Responsibilities:

* Bind the recorder to execution lifecycle:
  * run start
  * step recording
  * run termination
* Ensure:
  * no steps are recorded outside a run
  * exactly one active run per process (initially)

This is how the SDK guarantees **complete traces**.

***

## 5. Safety, Redaction, and Compliance (Missing Section)

The SDK must enforce safety **by default**.

### Secret Redaction

Before persistence, the SDK must:

* Scan:
  * prompts
  * tool inputs/outputs
  * memory snapshots
* Mask:
  * API keys
  * tokens
  * credentials
* Ensure:
  * redaction happens before disk write
  * original values are never persisted

***

### Trace Size Control

The SDK must:

* Enforce configurable limits:
  * maximum number of steps
  * maximum snapshot size
* When limits are exceeded:
  * collapse old steps
  * record truncation metadata
  * continue safely

This prevents runaway agents from exhausting disk or memory.

***

## 6. Deterministic Replay Guarantees (Explicitly Required)

The SDK must ensure that replay requires **no re-execution**.

It must capture:

* all tool outputs
* all LLM outputs
* random seeds
* retry behavior
* execution order

Replay correctness is a **hard requirement**, not a best-effort feature.

***

## 7. Verification & Demo

* Create a `demo_agent.py` that:
  * uses reasoning, tools, retries, and memory
  * produces a non-trivial run
* Verify:
  * `meta.json` completeness
  * strict step ordering in `steps.jsonl`
  * snapshot correctness
  * tool output persistence
* Confirm the generated run opens **unchanged** in the ACP VS Code extension

***

## 8. SDK Usage Pattern (Goal)

```
import acp

# Initialize run
acp.init(agent_version="1.0", llm="gpt-4", seed=42)

@acp.tool
def my_tool(arg):
    return "result"

with acp.step(phase="reason"):
    # agent logic
    pass

```

Additional guarantees to enforce:

* Calling `acp.step` outside an active run is an error
* Nested steps are tracked correctly
* Exceptions are always recorded before propagation

***

## 9. Explicit Non-Goals (Enforced by Design)

The ACP Python SDK must not:

* redesign agents
* modify prompts
* auto-fix logic
* apply changes
* simulate counterfactuals
* generate explanations

It records **facts**, not interpretation
